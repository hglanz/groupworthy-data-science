{
  "hash": "485f0601c72d6a3ce45cd6d8d137ab34",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Untitled\"\nexecute: \n  eval: false\n---\n\n\n\n\n\n## Application exercise\n\n::: {.callout-tip title=\"Reminder to reflect\"}\nAs you work through this application exercise, make note: what is challenging? What feels comfortable? What insights do you gain from collaborating with others? What ideas/strategies do you want to remember going forward?\n:::\n\n**Goal:** In the `diamonds` dataset, we want to understand the relationship between `price` and size (`carat`). We want to explore variation along two choices:\n\n1. The variables included in the model. We'll explore 3 sets of variables:\n    - No further variables (just `price` and `carat`)\n    - Adjusting for `cut`\n    - Adjusting for `cut` and `clarity`\n    - Adjusting for `cut`, `clarity`, and `color`\n2. Whether or not to remove outliers in the `carat` variable. We'll define outliers as cases whose `carat` is over 3 SDs away from the mean.\n\n\n**Exercise 1:** Use `crossing()` to create the data frame of argument combinations for our analyses. Note that you can create a list of **formula** objects in R with `c(y ~ x1, y ~ x1 + x2)`.\n\n<details>\n  <summary>Solution</summary>\n  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_arg_combos <- crossing(\n    mod_formula = c(price ~ carat, \n                    price ~ carat + cut,  \n                    price ~ carat + cut + clarity,  \n                    price ~ carat + cut + clarity + color),\n    remove_outliers = c(TRUE, FALSE)\n    )\n\ndf_arg_combos\n```\n:::\n\n\n\n\n</details>\n\n**Exercise 2:** Write a function that removes outliers in a dataset. The user should be able to supply the dataset, the variable to remove outliers in, and a threshold on the number of SDs away from the mean used to define outliers.\n\n<details>\n  <summary>Solution</summary>\n  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremove_outliers <- function(df, what_var, sd_thresh) {\n    df %>% \n        mutate(zscore = ({{ what_var }} - mean({{ what_var}}, na.rm = TRUE))/sd({{ what_var }}, na.rm = TRUE)) %>%\n        filter(zscore <= sd_thresh)\n}\n```\n:::\n\n\n\n\n</details>\n\n**Exercise 3:** Write a function that implements the analysis versions specifically for the `diamonds` dataset. The user will not specify the dataset as an argument but will input the model formula and whether or not to remove outliers (cases whose `carat` is over 3 SDs away from the mean).\n\n<details>\n  <summary>Solution</summary>\n  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(mod_formula, remove_outliers) {\n    if (remove_outliers) {\n        diamonds_clean <- remove_outliers(diamonds, what_var = carat, sd_thresh = 3)\n    } else {\n        diamonds_clean <- diamonds\n    }\n    \n    lm(mod_formula, data = diamonds_clean)\n}\n```\n:::\n\n\n\n\n</details>\n\n<!-- **Exercise 4:** Write a `for` loop that stores the fitted linear models from all versions of the analysis. -->\n\n<!-- Note that you can pull out the contents of a single data frame column in many ways. For a data frame `df` with a variable named `x`: -->\n\n<!-- - `df$x` -->\n<!-- - `df %>% pull(x)` -->\n<!-- - `df[[\"x\"]]` -->\n\n<!-- <details> -->\n<!--   <summary>Solution</summary> -->\n\n<!-- ```{r} -->\n<!-- lin_mod_res_for <- vector(mode = \"list\", length = nrow(df_arg_combos)) -->\n\n<!-- for (i in seq_along(lin_mod_res_for)) { -->\n<!--     this_formula <- df_arg_combos$mod_formula[[i]] # Double [[ for the **list** of formulas -->\n<!--     this_remove_outliers <- df_arg_combos$remove_outliers[i] # Single [ for the **atomic vector** of logicals -->\n<!--     lin_mod_res_for[[i]] <- fit_model( -->\n<!--         mod_formula = this_formula, -->\n<!--         remove_outliers = this_remove_outliers -->\n<!--     ) -->\n<!-- } -->\n<!-- ``` -->\n\n<!-- </details> -->\n\n**Exercise 5:** Use `pmap()` from `purrr` to replicate what you did with the `for` loop.\n\n<details>\n  <summary>Solution</summary>\n  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlin_mod_res_pmap <- pmap(df_arg_combos, fit_model)\n```\n:::\n\n\n\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}