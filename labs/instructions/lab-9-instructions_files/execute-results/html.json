{
  "hash": "fca54d957c893840b8e630cfcc00fb15",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab 9: Data Simulation Exploration\"\nformat: \n  html:\n    code-tools: true\n    toc: true\neditor: source\nexecute: \n  error: true\n  eval: false\n  message: false\n  warning: false\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Random Babies Simulation\n\nPerhaps you have seen the [Random Babies applet](https://www.rossmanchance.com/applets/2021/randombabies/RandomBabies.html)? \nSuppose one night at a hospital four babies are born. The hospital is not very\norganized and looses track of which baby belongs to each parent(s), so they \ndecide to return the babies to parents at random. Here, we are interested in the\nnumber of babies that are correctly returned to their respective parent(s).\n\n**1. Simulate the distribution of the number of babies that are correctly returned. Use 10,000 simulations.**\n\n::: callout-tip\nWrite a function to accomplish one simulation, then use `map_int()` to run\n10,000 simulations. \n\nKeep in mind that your function needs to output a single number (not data frame) \nfor it to be compatible with `map_int()`!\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandomBabies <- function(nBabies){\n  ...\n}\n\nresults <- map_int(.x = 1:10000,\n                  .f = \n                  )\n```\n:::\n\n\n\n\n**2. Create a table displaying the proportion of simulations where 0, 1, 2, 3, and 4 babies were given to their correct parent(s).** Hint: A `pivot_wider()` will be helpful here!\n\n::: callout-tip\nThe output of your `map_int()` is a vector, but to make a nice table (and plot) \nyou need this to be a data frame! Luckily, the `enframe()` function does just \nthat--it converts a vector to a data frame. \n\nYou may find the following code helpful:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenframe(results, \n        name = \"simulation_number\", \n        value = \"ncorrect\")\n```\n:::\n\n\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n**3. Now create a barplot showing the proportion of simulations where 0, 1, 2, 3, and 4 babies were given to their correct parent(s).** \n\n::: callout-tip\nYou may find the following code helpful:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeom_bar(mapping = aes(y = after_stat(count) / sum(after_stat(count))\n                       )\n         )\n```\n:::\n\n\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Central Limit Theorem -- Optional & Somewhat Spicy\n\nYou have encountered the Central Limit Theorem in your previous statistics \nclasses, whether or not is has been explicitly discussed. The Central Limit \nTheorem states that: \n\n> The sampling distribution of the mean will always be normally distributed, as\n> long as the sample size is large enough, regardless of the underlying \n> distribution of the population. \n\nRemember back to your first statistics class when you had to check if the \nsample size was larger than 30 when testing if groups had different means? \nThat's because of the Central Limit Theorem! Under certain conditions \n(e.g., sample size) the Central Limit Theorem ensures that the distribution \nof sample means will be approximately Normal, regardless of how skewed the \nunderlying distribution of the population may be. \n\nA fundamental misunderstanding of the Central Limit Theorem is that it states \nthat as a sample size gets larger, the population will be normally distributed. \nThis is not the case, so let's do some exploring!  \n\n**4. Write a function that simulates a specified number of sample means, for samples of size 100 drawn from a Chi-Squared distribution. Your function should allow the user to input:**\n\n- **the number of means to simulate**\n- **the degrees of freedom of the Chi-Squared distribution used to simulate data** \n\nI've provided some skeleton code to get you started. :) \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_means <- function(n, df){\n  map_dbl(.x = , \n          .f = ~rchisq(n = 100, ...) %>% mean()\n          )\n}\n```\n:::\n\n\n\n\n**5. Next, let's use the `crossing()` function to make a grid with inputs we want to pass into the `simulate_means()` function. Specifically, we want to explore the following values:**\n\n-  **`n` = 10, 100, 1000, 10000**\n-  **`df` = 10**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- crossing(n = c(10, 100, 1000, 10000), \n                 df = 5)\n```\n:::\n\n\n\n\n**6. Now, use a `p_map()` to create a new column of simulated means (using the `simulate_means()` function), for every value in your `grid`.**\n\n::: {.callout-tip}\nYou will want to use the `unnest()` function to extract the results of the\n`p_map()` (stored in the `simulated_means` column). \n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_simulations <- grid |> \n  mutate(simulated_means = pmap(.l = list(), \n                                .f = simulate_means)\n         ) |> \n  unnest() \n```\n:::\n\n\n\n\n**7. Create a table of the means from each of the simulations (10, 100, 1000, and 10000).** \nHint: Make sure your columns have descriptive names!\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n**8. Create a plot showing the distribution of simulated means from each of the simulations. Each simulation (10, 100, 1000, and 10000) should be its own facet!**\nHint: Make sure your facets have descriptive names! You might also want to free\nthe y-axis of the plots, since there are substantial differences in the sample\nsizes between the simulations. \n\n**For extra pizzazz, add a vertical line for true mean (for a Chi-Square the mean is the degrees of freedom).**\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Challenge 9\n\nInstructions for the challenge can be found on the course website or through \nthe link in Canvas! \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}